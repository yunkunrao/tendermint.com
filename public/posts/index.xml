<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Tendermint</title>
    <link>http://tendermint.com/posts/</link>
    <description>Recent content in Posts on Tendermint</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 19 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://tendermint.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Tendermint Socket Protocol (TMSP)</title>
      <link>http://tendermint.com/posts/tendermint-socket-protocol/</link>
      <pubDate>Sat, 19 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/tendermint-socket-protocol/</guid>
      <description>

&lt;h3 id=&#34;tutorials:9ee5291616336eaccb53b94be2d99fab&#34;&gt;Tutorials&lt;/h3&gt;

&lt;p&gt;After you read this post, don&amp;rsquo;t forget to check out our tutorials!  They also appear at the end of this page.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tendermint.com/tutorials/run-your-first-tmsp-application/&#34;&gt;Run your first TMSP application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tendermint.com/tutorials/launch-a-tmsp-testnet/&#34;&gt;Launch a TMSP testnet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;motivation:9ee5291616336eaccb53b94be2d99fab&#34;&gt;Motivation&lt;/h3&gt;

&lt;p&gt;Thus far, all blockchains &amp;ldquo;stacks&amp;rdquo; (such as &lt;a href=&#34;https://github.com/bitcoin/bitcoin&#34;&gt;Bitcoin&lt;/a&gt;) have had a monolithic design.  That is, each blockchain stack is a single program that handles all the concerns of a decentralized ledger; this includes P2P connectivity, the &amp;ldquo;mempool&amp;rdquo; broadcasting of transactions, consensus on the most recent block, account balances, Turing-complete contracts, user-level permissions, etc.&lt;/p&gt;

&lt;p&gt;This approach to blockchain development has several problems.  First, creating a new blockchain requires forking an existing blockchain stack, and this comes with the cost of complexity.  First you need to understand all the components of a blockchain stack, even those that aren&amp;rsquo;t directly relevant to the logic of your application.  This is especially true when the codebase is not modular in design and suffers from &amp;ldquo;spaghetti code&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Another problem with this approach is that it limits you to the language of the blockchain stack (or vice versa).  In the case of Ethereum which supports a Turing-complete bytecode virtual-machine, it limits you to languages that compile down to that bytecode; today, those are Serpent and Solidity.&lt;/p&gt;

&lt;p&gt;In contrast, our approach is to decouple the consensus engine and P2P layers from the details of the application state of the particular blockchain application.&lt;/p&gt;

&lt;h3 id=&#34;intro-to-tmsp:9ee5291616336eaccb53b94be2d99fab&#34;&gt;Intro to TMSP&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tendermint/tendermint&#34;&gt;Tendermint Core&lt;/a&gt; (the &amp;ldquo;consensus engine&amp;rdquo;) speaks to the application via a socket protocol called &lt;a href=&#34;https://github.com/tendermint/tmsp&#34;&gt;TMSP&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To draw an analogy, lets talk about a well-known cryptocurrency, Bitcoin.  Bitcoin is a cryptocurrency blockchain where each node maintains a fully audited Unspent Transaction Output (UTXO) database. If one wanted to create a Bitcoin-like system on top of TMSP, Tendermint Core would be responsible for&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sharing blocks and transactions between nodes&lt;/li&gt;
&lt;li&gt;Establishing a canonical/immutable order of transactions (the blockchain)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The application will be responsible for&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maintaining the UTXO database&lt;/li&gt;
&lt;li&gt;Validating cryptographic signatures of transactions&lt;/li&gt;
&lt;li&gt;Preventing transactions from spending non-existent transactions allowing clients to query the UTXO database.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tendermint is able to decompose the blockchain design by offering a very simple API between the application process and consensus process.&lt;/p&gt;

&lt;p&gt;The API consists of 3 primary message types that get delivered from the core to the application.  The application replies with corresponding response messages.&lt;/p&gt;

&lt;p&gt;The messages are specified here: &lt;a href=&#34;https://github.com/tendermint/tmsp#message-types&#34;&gt;https://github.com/tendermint/tmsp#message-types&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;AppendTx&lt;/code&gt; message is the work horse of the application.  Each transaction in the blockchain is delivered with this message. The application needs to validate each transactions received with the &lt;code&gt;AppendTx&lt;/code&gt; message against the current state, application protocol, and the cryptographic credentials of the transaction. A validated transaction then needs to update the application state — by binding a value into a key values store, or by updating the UTXO database.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;CheckTx&lt;/code&gt; message is similar to &lt;code&gt;AppendTx&lt;/code&gt;, but it&amp;rsquo;s only for validating transactions.  Tendermint Core&amp;rsquo;s mempool first checks the validity of a transaction with &lt;code&gt;CheckTx&lt;/code&gt;, and only relays valid transactions to its peers.  Applications may check an incrementing nonce in the transaction and return an error upon &lt;code&gt;CheckTx&lt;/code&gt; if the nonce is old.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Commit&lt;/code&gt; message is used to compute a cryptographic commitment to the current application state, to be placed into the next block header. This has some handy properties. Inconsistencies in updating that state will now appear as blockchain forks which catches a whole class of programming errors. This also simplifies the development of secure lightweight clients, as Merkle-hash proofs can be verified by checking against the block hash, and the block hash is signed by a quorum of validators.&lt;/p&gt;

&lt;p&gt;There can be multiple TMSP socket connections to an application.  Tendermint Core creates two TMSP connections to the application; one for the validation of transactions when broadcasting in the mempool, and another for the consensus engine to run block proposals.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s probably evident that applications designers need to very carefully design their message handlers to create a blockchain that does anything useful but this architecture provides a place to start.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-determinism:9ee5291616336eaccb53b94be2d99fab&#34;&gt;A Note on Determinism&lt;/h3&gt;

&lt;p&gt;The logic for blockchain transaction processing must be deterministic.  If the application logic weren&amp;rsquo;t deterministic, consensus would not be reached among the Tendermint Core replica nodes.&lt;/p&gt;

&lt;p&gt;Solidity on Ethereum is a great language of choice for blockchain applications because, among other reasons, it is a completely deterministic programming language.  However, it&amp;rsquo;s also possible to create deterministic applications using existing popular languages like Java, C++, Python, or Go.  Game programmers and blockchain developers are already familiar with creating deterministic programs by avoiding sources of non-determinism such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;random number generators (without deterministic seeding)&lt;/li&gt;
&lt;li&gt;race conditions on threads (or avoiding threads altogether)&lt;/li&gt;
&lt;li&gt;the system clock&lt;/li&gt;
&lt;li&gt;uninitialized memory (in unsafe programming languages like C or C++)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gafferongames.com/networking-for-game-programmers/floating-point-determinism/&#34;&gt;floating point arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;language features that are random (e.g. map iteration in Go)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While programmers can avoid non-determinism by being careful, it is also possible to create a special linter or static analyzer for each language to check for determinism.  In the future we may work with partners to create such tools.&lt;/p&gt;

&lt;h3 id=&#34;tutorials-1:9ee5291616336eaccb53b94be2d99fab&#34;&gt;Tutorials&lt;/h3&gt;

&lt;p&gt;Follow these tutorials to quickly get started developing your TMSP application.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tendermint.com/tutorials/run-your-first-tmsp-application/&#34;&gt;Run your first TMSP application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tendermint.com/tutorials/launch-a-tmsp-testnet/&#34;&gt;Launch a TMSP testnet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;contributions:9ee5291616336eaccb53b94be2d99fab&#34;&gt;Contributions&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Many thanks to Zaki Manian for providing the &amp;ldquo;Intro to TMSP&amp;rdquo; section&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tendermint for Fast Settlement</title>
      <link>http://tendermint.com/posts/tendermint-for-fast-settlement/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/tendermint-for-fast-settlement/</guid>
      <description>

&lt;p&gt;Some experts in the nascent blockchain industry have said the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;The blockchain is just a database&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Blockchains don’t help with fast settlement&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;The future of finance on the blockchain may not involve consensus&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;You can build on top of the Bitcoin blockchain for fast settlement&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This short post will address these statements and paint a different picture.&lt;/p&gt;

&lt;h3 id=&#34;clearing-and-settlement-woes:c70e654fcbeba9e734c64c9df590bef4&#34;&gt;Clearing and settlement woes&lt;/h3&gt;

&lt;p&gt;Clearing and settlement are separate but related terms.  The source of the differences stems from the significant duration of time (on the order of days) for the delivery of assets (e.g. paper certificates used to take over a week to deliver by courier).  A clearinghouse provides faster settlement between two trading parties by acting as the counterparty for both.&lt;/p&gt;

&lt;p&gt;So, it isn&amp;rsquo;t the clearing that is slow. Part of the purpose of clearing is to mitigate the slowness of settlement.  The reason why we don&amp;rsquo;t have fast settlement is because &amp;ldquo;Current banking databases are disparate and therefore require reconciliation between each other.&amp;rdquo;, and, &amp;ldquo;the existence of [3rd party] consortia &amp;hellip; prevented banking systems from evolving, because there was no incentive for a single bank to create a better system outside of the consortia&amp;rdquo;  (&lt;a href=&#34;https://medium.com/design-matters-4/blockchains-and-banks-cef72f0fcf29&#34;&gt;source&lt;/a&gt;).  To solve the problem of reconciliation, we need a common ledger and platform.&lt;/p&gt;

&lt;p&gt;Once we have a common ledger, we can think about tradeoffs between security and settlement speed.  When settlement becomes fast on the order of seconds, human intermediation becomes difficult, which in turn means that we need the system to be as fault tolerant as possible.&lt;/p&gt;

&lt;h3 id=&#34;the-source-of-bitcoin-s-security:c70e654fcbeba9e734c64c9df590bef4&#34;&gt;The source of Bitcoin’s security&lt;/h3&gt;

&lt;p&gt;Bitcoin and Bitcoin’s proof-of-work (PoW) mining, or Nakamoto consensus, provides something that until 2008 had never existed before.  Bitcoin was the first open decentralized application to provide Byzantine fault-tolerant (BFT) consensus on a global currency ledger.  Nakamoto consensus is a novel BFT consensus algorithm that utilizes computational power as a proxy for membership.&lt;/p&gt;

&lt;p&gt;The security of Nakamoto consensus depends on extrinsic factors such as the availability of energy and access to semiconductor fabs.  Ignoring these factors, the security of Nakamoto consensus can be modeled by the makeup and diversity of the mining network.  The more diverse the mining participants, the more difficult it is to coordinate a sufficiently large coalition to successfully attack the network and cause double-spends. If we discount the difficulty of coordination (which may be prudent considering that major mining pools communicate with each other routinely), what’s left is the opportunity cost of producing blockchain forks&amp;ndash;just 25 bitcoins per block at today’s inflationary reward schedule.&lt;/p&gt;

&lt;p&gt;The Bitcoin blockchain does help with settlement in that it provides a BFT ledger.  The problem is that Nakamoto consensus is slow and expensive, as its security is only proportional to the cumulative sum of energy burned over time.&lt;/p&gt;

&lt;h3 id=&#34;classical-bft-enables-additive-security:c70e654fcbeba9e734c64c9df590bef4&#34;&gt;Classical BFT enables additive security&lt;/h3&gt;

&lt;p&gt;Classical BFT consensus algorithms don’t rely on the opportunity cost of energy expenditure for security.  They use pseudonymous identities and cryptographic signatures to ensure that a sufficient quorum of participants approve of new transactions before they are committed.  These algorithms had been around since the 70’s and 80’s, and culminated in 1999 with the renowned PBFT algorithm.  Existing PBFT solutions are difficult to use or incomplete (&lt;a href=&#34;http://arxiv.org/abs/1110.4854&#34;&gt;source&lt;/a&gt;), so there is a need for a new free and open-source implementation.  Tendermint is such an open-source implementation of the PBFT consensus protocol (see &lt;a href=&#34;http://tendermint.com/posts/tendermint-vs-pbft/&#34;&gt;explanation&lt;/a&gt;).  Tendermint can commit blocks to finality on a global ledger with hundreds of validators on the order of seconds.&lt;/p&gt;

&lt;p&gt;Unlike Nakamoto consensus, there is no extrinsic opportunity cost for signing conflicting blocks on the blockchain, since cryptographic signatures are practically free. Instead, we can design classical BFT consensus protocols to be &lt;em&gt;accountable&lt;/em&gt;; that is, &lt;strong&gt;when the blockchain is forked, we can review the signatures and determine which participants caused the fork to happen&lt;/strong&gt;.  If we combine this BFT accountability with the concept of collateral, we get something that I’m calling &lt;em&gt;additive-security&lt;/em&gt;.  Each individual participant of the BFT consensus process might only post a small amount of collateral (limited by their confidence in ability to secure their hardware and software), but &lt;strong&gt;the total effective collateral can be large&lt;/strong&gt;.  For example, if there are 1000 validators that each post $1M worth of collateral, a double-spend attack would cost attackers at minimum $333M dollars ($1M × 1000 × ⅓).  By the way, we can increase the minimum fraction of collateral at stake (beyond ⅓) by requiring a larger quorum of validators to commit each block.&lt;/p&gt;

&lt;p&gt;A consortium of banks could run a Tendermint blockchain where the validators are publicly identified.  Each validator can post collateral secured by legal contracts with real assets held in escrow by each other, and/or with tokens intrinsic to the blockchain.  Each validator on such a blockchain network would secure their public/private key to the best of their ability.  To mitigate the risk of accidents and hacks, each validator keypair can be derived from multiple keypairs that produce signatures jointly using a cryptographic threshold signature scheme;  in effect, each validator node would be running a BGA consensus network recursively for additional security.  Tendermint validators uses the Ed25519 Schnorr signature scheme because it supports cryptographic threshold signatures (&lt;a href=&#34;http://cacr.uwaterloo.ca/techreports/2001/corr2001-13.ps&#34;&gt;source&lt;/a&gt;).  I&amp;rsquo;ll write more about this in a future post, but for now lets just say that, under this scheme, a single bank with a single effective public key on the main ledger could reasonably post billions of dollars in collateral.&lt;/p&gt;

&lt;p&gt;For public permissionless blockchains, Nielsen&amp;rsquo;s law of internet bandwidth is at play.  If we naively assume that doubling the number of validators requires four times the bandwidth, and that bandwidth doubles every two years, every four years a public blockchain can support twice as many validators (thus naively twice as much collateral) and still commit blocks at the same speed.  I bet we can do better.&lt;/p&gt;

&lt;h2 id=&#34;fin:c70e654fcbeba9e734c64c9df590bef4&#34;&gt;Fin&lt;/h2&gt;

&lt;p&gt;With publicly identified Tendermint validators with collateral at risk, we can have a shared decentralized ledger that offers fast settlement.  This is a novel concept and one that has the potential to change the nature of banking itself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tendermint vs PBFT</title>
      <link>http://tendermint.com/posts/tendermint-vs-pbft/</link>
      <pubDate>Sat, 03 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/tendermint-vs-pbft/</guid>
      <description>

&lt;p&gt;Tendermint was originally inspired by the DLS algorithm (&lt;a href=&#34;http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf&#34;&gt;link&lt;/a&gt;).  After several iterations to improve efficiency, (namely, making it more asynchronous), it has become quite similar to the PBFT algorithm (&lt;a href=&#34;http://www.pmg.lcs.mit.edu/papers/osdi99.pdf&#34;&gt;link&lt;/a&gt;).  This document serves to illustrate the similarities and differences between Tendermint and PBFT.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tendermint&lt;/th&gt;
&lt;th&gt;PBFT&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;proposer&lt;/td&gt;
&lt;td&gt;primary&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;validator&lt;/td&gt;
&lt;td&gt;replica&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;propose step&lt;/td&gt;
&lt;td&gt;pre-prepare phase&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;prevote step&lt;/td&gt;
&lt;td&gt;prepare phase&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;precommit step&lt;/td&gt;
&lt;td&gt;commit phase&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;round change&lt;/td&gt;
&lt;td&gt;view change&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;terminology comparison between Tendermint and PBFT&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;byzantine-fault-tolerance:e7e7efb14f67469318954b6d027907a0&#34;&gt;Byzantine fault tolerance&lt;/h3&gt;

&lt;p&gt;Both PBFT and Tendermint are Byzantine fault-tolerant transaction systems.  Both can handle up to ⅓ of malicious Byzantine validators/replicas.  Both require three steps/phases;  the first for broadcasting the block, and the last two for broadcasting signatures.  Finally, both require two quorums of signatures to commit a block.&lt;/p&gt;

&lt;p&gt;Where the two differ is in what happens when more than ⅓ of validators are Byzantine.  In PBFT, when there are between ⅓ and ⅔ of Byzantine validators, no guarantees are provided whatsoever; the attackers can return arbitrary results to the client (&lt;a href=&#34;https://www.usenix.org/conference/nsdi-07/beyond-one-third-faulty-replicas-byzantine-fault-tolerant-systems&#34;&gt;source&lt;/a&gt;).  Tendermint’s consensus model considers a block to be committed when there are more than ⅔ of precommit signatures for the blockhash, which mitigates this issue.   Thus if ½ of the validators are Byzantine they can prevent future blocks from being committed; however, they cannot commit new blocks like they can in PBFT.&lt;/p&gt;

&lt;h3 id=&#34;round-robin-vs-sticky-leaders:e7e7efb14f67469318954b6d027907a0&#34;&gt;Round-robin vs sticky leaders&lt;/h3&gt;

&lt;p&gt;PBFT&amp;rsquo;s whitepaper, which was the inspiration for Hyperledger, illustrates a &amp;ldquo;sticky&amp;rdquo; leader (a.k.a. primary/proposer) system.  Tendermint&amp;rsquo;s specification describes a round-robin scheme for selecting new leaders for every block.&lt;/p&gt;

&lt;p&gt;In some scenarios, the sticky-leader approach has an advantage over the round-robin approach; the throughput in transactions-per-second is higher with sticky-leaders because the leader doesn&amp;rsquo;t have to wait for block confirmations before proposing the next block.  On the other hand, the round-robin approach has the benefit that leaders are continuously tested (preventing possible cascading failures), and the power to re-order transactions is shared equally among the participants.&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t have to pick one solution; we can combine the two approaches into a hybrid scheme.  Fortunately, making this change is straightforward in Tendermint, so it&amp;rsquo;s easy to configure it for any purpose.&lt;/p&gt;

&lt;h3 id=&#34;dynamic-membership:e7e7efb14f67469318954b6d027907a0&#34;&gt;Dynamic membership&lt;/h3&gt;

&lt;p&gt;The PBFT algorithm assumes a fixed set of replicas/validators in the network.  This may work for internal systems, but it doesn&amp;rsquo;t work for &amp;ldquo;consortium&amp;rdquo; or &amp;ldquo;public&amp;rdquo; blockchains where the participants are expected to change over time.  Tendermint supports dynamic membership safely by requiring a +⅔ quorum of validators to approve of membership changes.  The reference implementation allows anyone to post a bond collateral (with intrinsic coins), but other variations are possible (especially when combined with our permissions framework).  For example, Tendermint could be easily modified to reject new members by default, and only approve new members that have been whitelisted (perhaps by an independent third party).&lt;/p&gt;

&lt;h3 id=&#34;epidemic-gossip-vs-point-to-point:e7e7efb14f67469318954b6d027907a0&#34;&gt;Epidemic gossip vs point-to-point&lt;/h3&gt;

&lt;p&gt;The PBFT algorithm illustrates a point-to-point consensus algorithm, which is simpler but is less robust to disruptions in the network.  Tendermint&amp;rsquo;s implementation uses an epidemic gossip protocol to ensure that consensus can be reached as long as the network is connected, no matter how many point-to-point edge connections have been broken.&lt;/p&gt;

&lt;h3 id=&#34;block-propagation-optimizations:e7e7efb14f67469318954b6d027907a0&#34;&gt;Block propagation optimizations&lt;/h3&gt;

&lt;p&gt;Tendermint goes a step further than PBFT and implements a BitTorrent/LibSwift-inspired algorithm to quickly broadcast transaction blocks.  This makes the most out of limited available bandwidth to commit transactions sooner.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://www.ict.kth.se/courses/ID2210/presentation-papers/2012%20-%20Performance%20Analysis%20of%20Libswift.pdf&#34;&gt;&lt;em&gt;Performance Analysis of the Libswift P2P Streaming Protocol&lt;/em&gt;&lt;/a&gt; for details on how LibSwift fares in “flashcrowd” scenarios, which is similar to new block propagations in Tendermint.&lt;/p&gt;

&lt;h3 id=&#34;self-balancing-merkle-trees:e7e7efb14f67469318954b6d027907a0&#34;&gt;Self-balancing Merkle trees&lt;/h3&gt;

&lt;p&gt;PBFT and its implementation (the BFS filesystem) doesn&amp;rsquo;t provide much by way of useful data structures.  Tendermint ships with a self-balancing Merkle tree library which can be used to keep track of application data (e.g. account balances) and prove any part of the application state to a client (with a Merkle proof and quorum of signatures).  Of course, it&amp;rsquo;s not necessary to use such a data structure if you need to build a blockchain that can handle a million transactions per second &amp;ndash; for that, you should combine Tendermint with an LMAX &amp;ldquo;disruptor&amp;rdquo; (&lt;a href=&#34;http://martinfowler.com/articles/lmax.html&#34;&gt;source&lt;/a&gt;) to process all transactions in memory.&lt;/p&gt;

&lt;p&gt;The self-balancing Merkle tree data structure also comes in handy when implementing a parallel-blockchain architecture.  Since the logic for light-client verification of application state is so cheap, efficient, and safe&lt;sup&gt;*&lt;/sup&gt;, the same logic can be used for nodes and validators to keep track of the application state in foreign blockchains.&lt;/p&gt;

&lt;h2 id=&#34;fin:e7e7efb14f67469318954b6d027907a0&#34;&gt;Fin&lt;/h2&gt;

&lt;p&gt;Though Tendermint was developed independently from PBFT, both algorithms share more than a few similarities. Both algorithms attempt to approach optimality in fault tolerance and performance.  Given the similarities, developers wishing to build BFT systems should consider building on Tendermint, which is furthest ahead at meeting the requirements laid out in this paper about PBFT:&lt;/p&gt;

&lt;blockquote&gt;
“Interestingly, we may find that the current BFT debate may evolve to resemble the microkernel debate, with one camp advocating that the BFT concept is ultimately impractical for real-world applications and the other camp advocating that it is not the concept that is impractical/faulty, but it is the implementation that is impractical/faulty. Building a complete implementation that supports a real application for a long duration rather than for the length of time it takes to build and test a prototype implementation, that does not cut corners, that is not missing features, that does not make optimizations that break down in corner cases, that can be applied to more than one application, and that has good performance will go a long way to settling the debate. A tall order, for sure.”
&lt;/blockquote&gt;

&lt;p&gt;&lt;cite&gt;&lt;a href=&#34;http://arxiv.org/pdf/1110.4854.pdf&#34;&gt;&lt;em&gt;On the Practicality of Byzantine Fault Tolerance&lt;/em&gt;&lt;/a&gt;, 2011&lt;/cite&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;*&lt;/sup&gt; &lt;em&gt;This isn’t completely implemented yet.  The Merkle proof logic is implemented, but we still need to implement a data structure to communicate validator set changes to clients, and ideally client code in Javascript as a demo.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cases for Tendermint</title>
      <link>http://tendermint.com/posts/cases-for-tendermint/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/cases-for-tendermint/</guid>
      <description>

&lt;p&gt;You may have an application that benefits from blockchain technology, and you may be trying to figure out whether to build that on Bitcoin, some meta-coin protocol like Counterparty, with Solidity/Serpent on the Ethereum virtual machine, or on a new blockchain stack altogether.  Actually, you should seriously consider building on Tendermint.&lt;/p&gt;

&lt;h2 id=&#34;a-little-background-on-tendermint:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;A little background on Tendermint&lt;/h2&gt;

&lt;p&gt;Tendermint is not a fork of Bitcoin, NXT, Ripple, or Ethereum.  Tendermint is its own blockchain stack written from the ground up.  It was built to be the base blockchain stack from which to fork off of for a wide variety of decentralized applications.  It started back in 2014 as an ambitious project to solve the Bitcoin mining problem and bring real Byzantine fault-tolerant consensus to cryptocurrencies.  First we adapted an existing BGA consensus algorithm to make it suitable for blockchains.  For the actual implementation we considered forking Bitcoin, NXT, BitShares, and other projects, but none could easily accommodate the desired project architecture.  So, a brand spanking new blockchain stack was born.&lt;/p&gt;

&lt;p&gt;Tendermint offers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Byzantine fault-tolerant consensus with unparalleled speed and security guarantees &amp;ndash; without mining. &lt;a href=&#34;https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm&#34;&gt;(see spec)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A very clean codebase with clear separation of concerns &amp;ndash; no spaghetti, thanks Golang!&lt;/li&gt;
&lt;li&gt;Throttled/fair P2P stack to handle multiplexed channels of communication.&lt;/li&gt;
&lt;li&gt;Clear P2P logic with the &lt;a href=&#34;https://en.wikipedia.org/wiki/Reactor_pattern&#34;&gt;reactor pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On top of this foundation, we&amp;rsquo;ve built more advanced blockchain features.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A compatible and efficient Ethereum VM implementation&lt;/li&gt;
&lt;li&gt;A permissions system that works across accounts and VM contracts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;re going to build more exciting features going forward, except this time we&amp;rsquo;ll blog about it while we do it, so hang on to your metaphorical horses.&lt;/p&gt;

&lt;h2 id=&#34;on-tendermint-consensus:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;On Tendermint consensus&lt;/h2&gt;

&lt;p&gt;The consensus system is the foundational layer of any blockchain stack. It is the process by which all of the transaction validators (equivalent to miners in Bitcoin) agree on the state of the network.  Improvements in speed, security, and cost of a consensus system ripple up and improve the performance of any network or application built on top of it.  Let&amp;rsquo;s dive into some examples to get a sense of how it works.&lt;/p&gt;

&lt;h3 id=&#34;case-1-payment-verification:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Case 1: Payment verification&lt;/h3&gt;

&lt;p&gt;Say that your mobile phone is connected to untrusted wifi, and you&amp;rsquo;re making a business deal with Satoshi.  Satoshi just sent you a large payment, and you need to verify that this payment was committed onto the blockchain network irreversibly.&lt;/p&gt;

&lt;p&gt;With Bitcoin, you generally need to wait up to 6 confirmation blocks (about 1 hour, sometimes longer) to consider a transaction fully committed.  For very large payment transactions you should wait even longer, because the security afforded by the blockchain miners is no greater than the cost of double-spending that transaction, which is today only about 25 Bitcoins per reverted block, and soon to be half of that.&lt;/p&gt;

&lt;p&gt;With Tendermint, a global network of 1000 independent validators can commit a transaction in less than 60 seconds.  The time required to commit only gets shorter with increased bandwidth and computational capacity of the nodes of the network.  In the near future we&amp;rsquo;ll be able to commit transactions on a global Tendermint blockchain with more than 1000 validators in a matter of seconds &amp;ndash; the only real limitation is the time it takes for light to travel around the globe.&lt;/p&gt;

&lt;h3 id=&#34;case-2-name-registry-lookup:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Case 2: Name registry lookup&lt;/h3&gt;

&lt;p&gt;Similar to case 1, but instead of verifying a payment, you need to verify Satoshi&amp;rsquo;s public key as registered under the name &amp;ldquo;@satoshi&amp;rdquo; on a name-registry blockchain.  The difference here as compared to case 1 is that instead of verifying a new transaction, you&amp;rsquo;re verifying the current value of a pre-registered key that may have been changed by other transactions.&lt;/p&gt;

&lt;p&gt;With Bitcoin (and Namecoin), you can verify that &amp;ldquo;@satoshi&amp;rdquo; was registered with a particular public key at some point in the past, but you wouldn&amp;rsquo;t know whether the public key had since been updated without downloading the whole blockchain.  This is because the presence of a name-registration transaction in the blockchain does not imply that later transactions hadn&amp;rsquo;t updated the value for that key.  In order for you to efficiently check for the current value of a name, the blockchain should support a balanced Merkle tree on the most recent name-registry state.  Even if Bitcoin/Namecoin did support such a data structure, you would still have to download and verify all the blockchain hashes and headers, and if the value might have been updated recently you&amp;rsquo;re still vulnerable to a fork-censorship attack.&lt;/p&gt;

&lt;p&gt;With Tendermint, all you need is the most recent blockhash signed by more than &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; of the validators, and a Merkle proof that proves the current value associated with the name &amp;ldquo;@satoshi&amp;rdquo;.  You don&amp;rsquo;t even need to wait for a single commit.  If you&amp;rsquo;re interested, see &lt;a href=&#34;https://github.com/tendermint/tendermint/wiki/Merkle-Trees#iavl-tree&#34;&gt;this link&lt;/a&gt; for more information on our balanced binary Merkle tree implementation.&lt;/p&gt;

&lt;p&gt;In future posts I&amp;rsquo;ll go into detail about the consensus algorithm and how it can provide these unique speed &amp;amp; security guarantees without proof-of-work mining.  For now, you can check the most recent Tendermint spec on the github wiki &lt;a href=&#34;https://github.com/tendermint/tendermint/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;tendermint-architecture:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Tendermint architecture&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://tendermint.com/images/tm_architecture.png&#34;/&gt;&lt;/p&gt;

&lt;p&gt;The above diagram is meant to show that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the consensus and transaction-execution (aka state-transition) modules are separate except for the shared (immutable/Merkle-ized) state.&lt;/li&gt;
&lt;li&gt;the consensus module takes a block, a commit for the block, and the last state, and uses the transaction-execution module to produce the next state.&lt;/li&gt;
&lt;li&gt;the VM call transaction is one of many transaction types offered by the transaction-execution module.&lt;/li&gt;
&lt;li&gt;the Ethereum VM (EVM) is only one of potentially many supported virtual machines.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you have a blockchain application in mind, on Tendermint there are two options to consider &amp;ndash; a smart contract on the Ethereum VM (and in the future, other VMs as well), or, a native transaction type (like SendTx or NameTx above).&lt;/p&gt;

&lt;h2 id=&#34;whether-to-develop-a-vm-smart-contract-or-develop-a-native-tendermint-contract:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Whether to develop a VM smart contract or develop a native Tendermint contract&lt;/h2&gt;

&lt;p&gt;The main benefit of a Turing-complete VM on a blockchain is that anyone can upload new contract logic onto the blockchain.  This is especially true on big-bad-public-blockchains (BBPB) like Bitcoin or Ethereum which were designed to allow anyone to upload new contract logic.  On the other hand, private blockchains and consortium blockchains that are more tightly managed may not need or even want arbitrary user-defined logic.&lt;/p&gt;

&lt;p&gt;Sometimes, writing an EVM contract is the right answer.  Use the EVM if you need to deploy the contract on a public blockchain such as Ethereum.  Use the EVM if you don&amp;rsquo;t have systems programming experience, and you find that writing a solidity contract is easier than writing in Golang.  Use the EVM if your contract-logic is simple enough that you wouldn&amp;rsquo;t mind stepping over bytecode execution to debug your contract.&lt;/p&gt;

&lt;p&gt;For other applications where the former exceptions don&amp;rsquo;t apply, you probably want to write native code on Tendermint for a variety of reasons &amp;ndash; Golang&amp;rsquo;s language tooling is better so debugging is easier, it&amp;rsquo;s computationally more efficient by far, and it removes two complex layers (one for the bytecode compiled language, and one for the VM itself).  If you want full control over your Merkle-ized data structures (e.g. without the 32-by-32-byte restriction of the EVM&amp;rsquo;s Patricia-trie) then you have to write your contract logic at the native level.  Tendermint provides you with the right tools to make this as easy as possible.&lt;/p&gt;

&lt;h2 id=&#34;fin:1825e1740a61156b2d6c2c2a5daacec7&#34;&gt;Fin&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go to &lt;a href=&#34;http://tendermint.com&#34;&gt;http://tendermint.com&lt;/a&gt; and sign up for the newsletter.&lt;/li&gt;
&lt;li&gt;Check out the &lt;a href=&#34;https://github.com/tendermint/tendermint/wiki&#34;&gt;Tendermint wiki&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Develop on Tendermint.&lt;/li&gt;
&lt;li&gt;Email us at hello@tendermint.com with your full name to join our Slack channel.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sidechains without Pegging</title>
      <link>http://tendermint.com/posts/sidechains-without-pegging/</link>
      <pubDate>Tue, 25 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/sidechains-without-pegging/</guid>
      <description>&lt;p&gt;There is an interesting debate happening between Bitcoin maximalists and the rest of the cryptocurrency community.&lt;/p&gt;

&lt;p&gt;First, BlockStream published Bitcoin maximalist paper on &lt;a href=&#34;http://www.blockstream.com/sidechains.pdf&#34;&gt;sidechains&lt;/a&gt;.
Then, Dominic of Pebble responded with due &lt;a href=&#34;http://blog.pebble.io/post/100702644738/on-sidechains-bitcoin-maximalism-and-freedom&#34;&gt;criticism&lt;/a&gt;.
Vitalik of Ethereum responded with &lt;a href=&#34;https://blog.ethereum.org/2014/11/20/bitcoin-maximalism-currency-platform-network-effects/&#34;&gt;more analysis&lt;/a&gt;.
And finally, Joel of Union Square Ventures wrote about a very &lt;a href=&#34;http://joel.mn/post/103546215249/the-blockchain-application-stack&#34;&gt;Bitcoin maximal world&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I’d like to add a few points to this conversation.&lt;/p&gt;

&lt;p&gt;First, let’s get this out of the way.  Metacoins like Counterparty are a nuisance for Bitcoin, regardless of the merits of the Counterparty protocol itself.  They benefit by taking advantage of the Bitcoin consensus network.  They bloat the block-chain space with transactions that aren’t relevant to other Bitcoin users.  The security of the Counterparty system is dependent on the security of Bitcoin’s, while it’s entirely possible that the market cap of assets in Counterparty become higher than that of Bitcoin, creating a lopsided security threat.  Metacoins will phase out as it becomes easier to bootstrap a secure coin with a pre-built consensus engine (such as Tendermint) that doesn’t rely on proof-of-work.  When the valuation of Bitcoin drops enough, Counterparty will be forced to migrate to its own block-chain too.&lt;/p&gt;

&lt;p&gt;The main thing I’d like to talk about is sidechains.  The term was first introduced by Bitcoin developers who were considering ways to encourage innovation in the alt-coin space while cutting down on the speculation and volatility that results from bootstrapping a new coin ex nihilo, by 1-way or 2-way pegging.  It works by having one block-chain track the consensus state of another block-chain.  It’s no wonder that the term “sidechain” refers to two distinct concepts — interchain-communication and pegging.  I like the term for its succinctness, so I’m going to try to hijack it to mean only interchain-communication — with or without pegging.&lt;/p&gt;

&lt;p&gt;The beautiful thing about sidechains is that it’s more than currency pegging.  For example, it can be used to run a decentralized exchange between two currencies.  You can do this now with “cross-chain-transactions”, but it requires both parties to be online, or for both to trust a few “smart oracles” with threshold signatures to handle the trade.  But when your block-chain can track the state of another with sidechain technology, you don’t have to trust anyone except the cryptocurrency network, which you trust already.  If you trust a block-chain enough to hold coins in it, you should trust the block-chain to enforce your exchange orders for you when you want to trade with a sidechain.  So now you can bootstrap a currency &lt;em&gt;and&lt;/em&gt; provide liquidity without trusted centralized exchanges, and really incentivize the development of new currencies without pegging the valuation onto &lt;s&gt;the Euro&lt;/s&gt;Bitcoin.  It’s especially important to have sovereign unpegged market-priced block-chains if the very thing you want to experiment with is monetary policy.&lt;/p&gt;

&lt;p&gt;Sidechain technology is more than 1-way or 2-way pegging to Bitcoin. It&amp;rsquo;s about contractual agreement between two communities represented by different consensus ledgers.  To pretend otherwise will only hurt the cryptocurrency movement.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Security of Cryptocurrency Protocols</title>
      <link>http://tendermint.com/posts/security-of-cryptocurrency-protocols/</link>
      <pubDate>Wed, 19 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tendermint.com/posts/security-of-cryptocurrency-protocols/</guid>
      <description>

&lt;p&gt;Many solutions to the consensus problem for cryptocurrencies have been proposed.  Since the innovation of Bitcoin’s proof-of-work based consensus algorithm&amp;ndash;where miners compete in an energy intensive game to determine the order of transactions&amp;ndash;several proof-of-stake algorithms have been proposed to make consensus faster while removing the reliance on energy expenditure.  The common objective of these protocols is to maintain a live decentralized transaction ledger while defending against double-spend attacks from malicious Byzantine actors deviating from the protocol.  Considering the financial nature of these protocols, we should strive to support a protocol that has well defined and robust security guarantees.&lt;/p&gt;

&lt;p&gt;The security analysis of cryptocurrency protocols is complicated by many factors.   One such complicating factor is the rational self-interested nature of participants.  The ideal protocol is an incentive aligned Nash equilibrium such that deviating from the protocol does not result in a net gain [&lt;a href=&#34;http://fc14.ifca.ai/papers/fc14_submission_82.pdf&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf&#34;&gt;2&lt;/a&gt;].  This is a topic worthy of its own post, but won’t be discussed further here.&lt;/p&gt;

&lt;p&gt;Another complicating factor is whether the power to achieve or disrupt consensus is extrinsic in origin (e.g. access to the production of mining equipment or cheap access to electricity) or intrinsic in origin (e.g. the “stake” of validators in proof-of-stake protocols) and whether the disruption of consensus&amp;ndash;especially via a successful double-spend attack&amp;ndash;is associated with a commensurate penalty.  The problem with extrinsic factors of security is that they are not easily quantifiable for analysis.  For example, the depreciation costs of Bitcoin mining hardware in the event of a successful double-spend attack may not be significant compared to the running costs of electricity in mining.  On the other hand existing proof-of-stake protocols do not have a well defined intrinsic penalty for instigators of a double-spend attack.  This is commonly called, ironically, the “nothing at stake” problem.  Newer protocols like the BitShares delegated-proof-of-stake protocol attempt to address this problem by placing the role of ranked-delegate at stake, but security is dependant on the extrinsic ability of stakeholders to accurately predict the future performance of delegates.&lt;/p&gt;

&lt;p&gt;What is needed is a radical simplification.  Security analysis is much simpler for an intrinsically secure cryptocurrency protocol when it can be proved that launching a double-spend attack necessarily results in a very high intrinsic penalty compared to the possible intrinsic gains.  Then, the protocol may be considered resistant to double-spent attacks assuming no further extrinsic complications.&lt;/p&gt;

&lt;p&gt;For example, consider a protocol that requires stakeholders to first post a surety bond before becoming a validator to participate in the consensus process.  To get the bonded coins back, the validator must first submit an unbonding transaction and wait a fixed, relatively long duration of time.  The validator’s only duty until the unbonding period is over is to participate in the protocol while taking care not to sign two blocks at the same height: the only way to fork the block-chain.  The validator that signs duplicitously loses its bonded coins as evidence of duplicity is entered onto the block-chain.  This protocol might adapt an existing Byzantine consensus algorithm from academic research (e.g. one proposed by Dwork, et al. [&lt;a href=&#34;http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf&#34;&gt;3&lt;/a&gt;]) to create a quorum of validators that agree on and sign the next block.  For a partially synchronous network (such as the Internet) at least two thirds of voting power is needed to agree on the next block, and up to one third of Byzantine voting power can be tolerated.  A double-spend attack implies a fork in the block-chain, which by simple arithmetic requires at least one third of voting power to have signed duplicitously.&lt;/p&gt;

&lt;p&gt;The above proposed protocol is secured by completely intrinsic means; it does not require a massive expenditure of energy to secure.  The total intrinsic penalty for successfully launching a double-spend attack (which is at least one third of all bonded coins as mentioned previously) can be adjusted by judiciously setting the incentives given to validators by way of fees or inflationary rewards.  The block-chain does not fork at all except in extraordinary circumstances, making it ideally suited for side-chain extensions.  It is to the my best knowledge the only completely decentralized cryptocurrency protocol that could be proven to be intrinsically incentive aligned.  Perhaps it is time to consider this kind of algorithm.&lt;/p&gt;

&lt;h2 id=&#34;links:332834bd1d2a52cc97bf52e097939cbf&#34;&gt;Links&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Eyal and Sirer.  The Majority is Not Enough. 2014, &lt;a href=&#34;http://fc14.ifca.ai/papers/fc14_submission_82.pdf&#34;&gt;http://fc14.ifca.ai/papers/fc14_submission_82.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kroll et al.  The Economics of Bitcoin Mining, or Bitcoin in the Presence of Adversaries. 2013, &lt;a href=&#34;https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf&#34;&gt;https://www.cs.princeton.edu/~kroll/papers/weis13_bitcoin.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dwork, Lynch, and Stockmeyer.  Consensus in the Presence of Partial Synchrony. 1988, &lt;a href=&#34;http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf&#34;&gt;http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>